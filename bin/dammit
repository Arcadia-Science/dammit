#!/usr/bin/env python
from __future__ import print_function

import argparse
import logging
import os
import sys

from dammit import common
from dammit import annotate
from dammit import databases
from dammit import dependencies
from dammit.tasks import print_tasks

logger = logging.getLogger(__name__)

def handle_databases(args):

    common.print_header('submodule: databases', level=1)

    missing = dependencies.do_check()
    if missing:
        logger.error('Install dependencies to continue; exiting')
        return 1
    
    db_dir = databases.get_dir(args)
    logger.debug('database dir: {0}'.format(db_dir))
    try:
        os.mkdir(db_dir)
    except OSError:
        logger.debug('database dir already exists')

    database_dict, tasks, missing = databases.do_check(db_dir,
                                                       args)
    print_tasks(tasks, logger=logger)
    
    if args.install:
        if missing:
            common.print_header('Installing databases', level=2)
            databases.run_tasks(db_dir, tasks)
        else:
            common.print_header('Nothing to install', level=2)

def handle_dependencies(args):

    common.print_header('submodule: dependencies', level=1)
    logger.debug('dependencies')
   
    missing = dependencies.do_check()


def handle_annotate(args):

    common.print_header('submodule: annotate', level=1)

    transcriptome = args.transcriptome
    out_dir = args.output_dir
    if out_dir is None:
        out_dir = transcriptome + '.dammit'
    out_dir = os.path.abspath(out_dir)

    missing_deps = dependencies.do_check()
    if missing_deps:
        logger.error('Install dependencies to continue; exiting')
        return 1
    
    db_dir = databases.get_dir(args)
    logger.debug('database dir: {0}'.format(db_dir))
    database_dict, _, missing_dbs = databases.do_check(db_dir,
                                                           args)

    if missing_dbs:
        logger.error('Install databases to continue; exiting')
        return 1

    results, tasks = annotate.get_tasks(transcriptome,
                                        database_dict,
                                        args.transcriptome_taxid,
                                        n_threads=args.n_threads,
                                        user_databases=args.user_databases)

    common.print_header('Running annotate!', level=2)
    logger.info('Transcriptome file: {0}'.format(transcriptome))
    logger.info('Output directory: {0}'.format(out_dir))
    print_tasks(tasks, logger=logger)

    annotate.run_tasks(transcriptome, out_dir, tasks)

def main():
    parser = argparse.ArgumentParser()
    # Debug can be used with all subcommands
    parser.add_argument('--debug', action='store_true', default=False)
    # Add subcommand parsers
    subparsers = parser.add_subparsers()
    
    '''
    `dammit databases` subcommand. This will run tasks to check for and
    install the databases. By default, only check their status; with
    `--install`, download and/or prepare them as well.
    '''
    databases_parser = subparsers.add_parser('databases')
    databases_parser.add_argument('--database-dir', default=None)
    databases_parser.add_argument('--install', action='store_true',
                                  default=False)
    databases_parser.add_argument('--full', action='store_true', default=False,
                        help='Do full annotation with uniref90')
    databases_parser.add_argument('--busco-group', default='metazoa')
    databases_parser.set_defaults(func=handle_databases)

    '''
    `dammit dependencies` subcommand. Checks for necessary executables
    on the system path and downloads them to the dammit folder if not present.
    Like the databases subcommand, takes an `install` option, which will put
    dependencies in the $HOME/.dammit/dependencies directory and give absolute
    paths to the task creators.
    '''
    dependencies_parser = subparsers.add_parser('dependencies')
    dependencies_parser.set_defaults(func=handle_dependencies)

    '''
    `dammit annotate` subcommand, which drives the primary program. The
    `--database-dir` and `--full` flags are the same as in the `databases`
    subcommand. `-o/--output-dir` specifies the directory where the results will
    be stored, and also the working directory where all annotate tasks will be
    executed. `--busco-group` specifies the BUSCO database to use; this must be
    one of BUSCOs builtins. `--n_threads` specifies the number of threads for
    each individual program to use (when applicable). `--user-databases` is an
    optional list of protein databases to run additional homology searches
    against and pull annotation information from; dammit can only take what it
    finds from these, so uninformative fasta headers will yield uninformative
    results. Finally, `transcriptome` is the transcriptome assembly to annotate.
    '''
    annotate_parser = subparsers.add_parser('annotate')
    annotate_parser.add_argument('--database-dir', default=None)
    annotate_parser.add_argument('--full', action='store_true', default=False,
                        help='Do full annotation with uniref90')
    annotate_parser.add_argument('-o', '--output-dir', default=None)
    annotate_parser.add_argument('--busco-group', default='metazoa')
    annotate_parser.add_argument('-x', '--transcriptome-taxid', type=int,
                                 required=True)
    annotate_parser.add_argument('--n_threads', type=int, default=1)
    annotate_parser.add_argument('--user-databases', nargs='+', default=[])
    annotate_parser.add_argument('transcriptome')
    annotate_parser.set_defaults(func=handle_annotate)

    #args, doit_args = parser.parse_known_args()
    args = parser.parse_args()

    # Print out the infos~
    meta = '{0}\n{1} {2}'.format(common.CONFIG['meta']['description'],
                                 ', '.join(common.CONFIG['meta']['authors']),
                                 common.CONFIG['meta']['date'])
    common.print_header(meta, 0)

    args.func(args)

if __name__ == '__main__':
    main()
